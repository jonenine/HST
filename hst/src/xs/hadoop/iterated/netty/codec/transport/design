需求:
1.网络条件恶略
2.提供完整的业务帧的回调,而不是简单的一个字节或是一行回调
3.完全自动化的规约解析功能,高容错的规约解析


1.模仿tcp/ip协议,每一次通讯都要有一次握手
          网络传输层
   (1)凡是没有接收到握手响应的,超时时间之后就重发(断连接重发,防止网络设备超时不转发)
   (2)握手响应可以包含状态码,如正确,错误,等候(增加握手请求方超时时间),者有一个字节
   (3)客户端在发送消息的时候,应该带着消息号,消息号只要不重复就可以了,服务器端在响应的时候应该带着客户端的消息号返回
   如果出现错误,重发的时候,应该带着消息号,在消息号达到上限的时候,比如short.maxvalue,客户端应该断掉连接,并将消息号
  清0
   (4)一个消息的结构由
         帧头(byte)+消息id(int)+重复发送次数(byte)+消息一共多少帧(short)+本次是第几帧(short)+负载大小(short)+负载(<32767)+crc32校验(long)+帧尾(byte)
        这样的格式可以传递一共1073676289字节的消息,也就是不到一个G的消息,再大的信息也超过jvm的处理能力
   
        如果一个消息拆的帧过多,会使得消息号超过上限,应该提前清0(这个无所谓,接收端并不按照这个顺序)
        负载最大长度应该可调,在条件不好的网络中,应该尽量缩小该值 
   
        过大的消息应该拆帧使用
   
         业务层:每个进程都有一个进程标识(主机名+进程或其他业务标识也是可以的),每种业务都有一个业务码(使用url表示),业务信息不应该绑定连接,而应该同每个业务的每个
客户端进程相关,这样一个socket断掉对业务本身不构成任何影响
    
        业务层应该采取消息监听器的机制,当一个消息到来后,应该调用监听器方法,生成一个业务的handler,这个handler绑定一个客户端进程(模仿netty的handler绑定连接)
但同一个客户端的多次的连接应该返回同一个handler
   addBusiness(businessUrl,new HandlerFactory(){
   		public ClientHandler(string clientId){
   			return new ClientHandler(clientId)
   		}
   })